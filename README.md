# 哈工大HIT编译原理实验

### 写给后来者

#### 	实验一：

- **我实现了什么？**

  ​	必做+所有的选做

- **哪些文件是需要手写的**

  ​	`lexical.l` 、`Node.h`、 `NodeUtil.c`、`syntax.y`

- **实现顺序是怎样的**

  ​	先实现`.l`文件，并同步验证`.l`文件是否能够正确输出`token`，接着设计`Node.h`树节点的数据结构，并实现`NodeUtil.c`对树插入、遍历等等操作，最后实现`syntax.y`

- **我的代码的缺陷**

  ​	对于终结符的属性值`literal`，我使用的是空指针，初心是想与其他人（使用了联合体）显得不一样，并且可以节省内存空间（微不足道），但实际上会碍手碍脚，还是建议用联合体，但相应的实验二三代码也需要修改。

  ​	错误处理部分，对于额外测试用例（`testcase_i`文件），并不能完全覆盖，这是我在验收前手忙脚乱做的改动，实在烂透了，建议重新设计，不过就算不改也能覆盖绝大部分错误了。

- **我的建议**

  ​	个人还是不太喜欢使用`bison`和`flex`这种自动化工具的实验，如果想更深入理解编译器的话，可以试试这本书——[`CraftingInterpreters`](https://www.craftinginterpreters.com/)，这本书使用`Java`语言，全手写了一个`“lox”`语言的编译器，我觉得学起来很不错诶。

  ​	通过验收的话至少需要熟悉这些产生式，并且知道每个文件的作用，以及从`cmm`代码文本是如何变成一颗语法分析树的过程（`.l`扫描器 传递`token` -> `.y`分析器 自底向下归约 -> `NodeUtil.c` 构造树）

  ​	建议在`gcc`编译时加上`-g`选项，这样可以更方便的用`gdb`定位出现的错误

------

#### 	实验二：

- **我实现了什么？**

  ​	必做+选做一（函数声明）

- **相比实验一改动了什么？**

  ​	为树节点增加了`literal_type`属性，为了实现选做一新加了一条产生式`Specifier FuncDec SEMI`，其他大概没了

- **哪些文件是需要手写的**

  ​	在实验一的基础上，需要再写`Semantic.c/.h`，`NodeTable.c/.h`

- **实现顺序是怎样的**

  ​	先设计符号表`NodeTable.h`，参照指导书即可，然后完成对符号表的增删改查`NodeTable.c`，接着就可以进行语法分析了，思路就是递归下降时的语法制导翻译，这时可能会对符号表进行重新的修改

- **我的代码的缺陷**

  - 对于结构体的操作太丑陋了，对于调用结构体里的域的写法其实是错误的，我想到代价比较小的修改方法是使用`Args`进行嵌套连接，一个`T-T-T`形状的链表，实现作用域范围，而我是在整个符号表里搜索（会导致额外测试用例 testcase/testcase_14错误）。
  - 选做一函数声明也有些问题，声明后再调用如果参数类型或数量不正确应该报错，但我的没有（testcase_19）
  
    -- 这个应该是在`ID LP RP`这个产生式时增加验证`argc`是否为`0` (写报告时意识到的)
  
  这两个是验收时才发现的，我没有动力改了，私密马赛
  
  但指导书里所有的测试用例都是可以通过滴

- **我的建议**

  ​	善用`gdb`（`gcc`编译时加上`-g`选项，超好用）与实验一的打印功能，使劲覆盖额外测试用例，是真的狠啊

  ------

  #### 实验三

- **我实现了什么**

### 祝你顺利，希望我的仓库对你有帮助~

其实这三个实验还是很锻炼代码能力的，如果能自己写是最好的啦

如果有问题的话可以提`issue`，我看到的话会尽快回答滴
