# 哈工大HIT编译原理实验

### 写给后来者

#### 	实验一：

- **我实现了什么？**

  ​	必做+所有的选做

- **哪些文件是需要手写的**

  ​	`lexical.l` 、`Node.h`、 `NodeUtil.c`、`syntax.y`

- **实现顺序是怎样的**

  ​	先实现`.l`文件，并同步验证`.l`文件是否能够正确输出`token`，接着设计`Node.h`树节点的数据结构，并实现`NodeUtil.c`对树插入、遍历等等操作，最后实现`syntax.y`

- **我的代码的缺陷**

  ​	对于终结符的属性值`literal`，我使用的是空指针，初心是想与其他人（使用了联合体）显得不一样，并且可以节省内存空间（微不足道），但实际上会碍手碍脚，还是建议用联合体，但相应的实验二三代码也需要修改。

  ​	错误处理部分，对于额外测试用例（`testcase_i`文件），并不能完全覆盖，这是我在验收前手忙脚乱做的改动，实在烂透了，建议重新设计，不过就算不改也能覆盖绝大部分错误了。

- **我的建议**

  ​	不太喜欢使用`bison`和`flex`这种自动化工具的实验，如果想更深入理解编译器的话，可以试试这本书——[`CraftingInterpreters`](https://www.craftinginterpreters.com/)，这本书使用`Java`语言，全手写了一个`lox`语言的编译器，结合课程来学习是很不错的。

  ​	如果只是想通过验收，那么至少需要熟悉这些产生式，并且知道每个文件的作用，以及从`cmm`代码文本是如何变成一颗语法分析树的过程（`.l`扫描器 传递`token` -> `.y`分析器 自底向下归约 -> `NodeUtil.c` 构造树）

  ​	建议在`gcc`编译时加上`-g`选项，这样可以更方便的用`gdb`定位出现的错误

------

#### 	实验二：

- **我实现了什么？**

  ​	必做+选做一（函数声明）

- **相比实验一改动了什么？**

  ​	为树节点增加了`literal_type`属性，为了实现选做一新加了一条产生式`Specifier FuncDec SEMI`，其他大概没了

- **哪些文件是需要手写的**

  ​	在实验一的基础上，需要再写`Semantic.c/.h`，`NodeTable.c/.h`

- **实现顺序是怎样的**

  ​	先设计符号表`NodeTable.h`，参照指导书即可，然后完成对符号表的增删改查`NodeTable.c`，接着就可以进行语法分析了，思路就是递归下降时的语法制导翻译，这时可能会对符号表进行重新的修改

- **我的代码的缺陷**

  - 对于结构体的操作太丑陋了，为了打印出不一样的错误类型居然复制粘贴了好多重复的函数，建议改一改。
  - 我用的是最简单的链表，不是很优雅，如果能用十字链表就最好了，其实我写到最后快变成一个`T-T-T`形状的链表，很接近实现选做二三的作用域以及类型等价了，不过没什么动力写下去了就是
  - 各个函数传递参数和返回值写的不太优雅，有点乱糟糟的，不好意思

- **我的建议**

  ​	善用`gdb`与实验一的打印功能，并牢记产生式

  ------

  #### 实验三

- 

### 祝你顺利，希望我的仓库对你有帮助~

其实这三个实验还是很锻炼代码能力的，如果能自己写是最好的啦

如果有问题的话可以提`issue`，我看到的话会尽快回答滴
